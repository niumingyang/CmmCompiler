# C--编译器

本项目实现一个C--语言的编译器，支持基本的变量/数组/函数/结构体等。C--语言的语法见`./Docs/Appendix_A.pdf`

## 环境要求

- GNU Linuc Release: Ubuntu 22.04.3 LTS
- GCC version: 11.4.0
- GNU Flex version: 2.6.4
- GNU Bison version: 3.8.2

## Usage
- `make parser`: 生成编译器parser
- `./parser $input.cmm $output.s [-p] [-ir $intercode.ir]`
    - `input.cmm`: 输入的cmm文件
    - `output.s`: 输出的汇编文件
    - `-p`: 打印语法树
    - `-ir`: 打印中间代码
- `make clean`: 清空输出

## 词法分析
词法分析将源代码从字符流转换为词法单元序列。在该部分当中，我们完成了主要的词法分析功能。主要使用GNU Flex配合正则表达式实现。

除去基本内容外，我们实现了八进制数以及十六进制数的词法识别，并通过了设计的测试；我们还实现了指数型浮点数的识别。

我们还对非法的`id`、`int`（3种进制）、`float`的错误情况进行了归纳，这样报错时更可以精确定位到是哪种可能的词法错误，使编译器功能得到了拓展。

我们还实现了单行注释和多行注释的词法识别，并且对于注释的错误使用也能给出报错。

## 语法分析
语法分析则负责检验该词法单元序列是否符合语法规范。在该部分当中，我们完成了主要的语法分析功能，还在文法中添加error产生式，来实现错误恢复。主要使用GNU Bison实现

我们首先在出现’)’ 、’]’ 、’}’ 、’;’这些符号的语法中加入 error 语句进行判断,然后又根据自己的了解在另外一些地方加入了error产生式对其他的一些错误进行恢复。

在消除语法冲突(“移入\规约”冲突或者“移入\移入”冲突)之后使用现实中出现的各种错误进行检验,最后确定了本次实验中的语法中可以检测出的错误以及错误类型。当 Bison 检查到了语法错误之后,将自动调用函数 yyerror,我们重写了这个函数保证没有输出,并重新构造了自己的错误输出函数来输出错误信息。

我们尝试了多种错误恢复的方法，并针对不同的情况输出不同的错误信息，以方便编译器更好的反映错误情况。

建立的语法分析树机构如下：

```cpp
typedef struct TreeNode {
    int lineno;
    char* type;
    char* info;
    struct TreeNode* child;
    struct TreeNode* next;
} TreeNode;
```

## 语义分析

- 实现符号表

  完成符号表的设计，将符号表的查找删除等操作抽象成函数接口。在具体设计上，我们采用了hash表作为数据结构，hash表的每个表项是一个指向`struct FieldList_`的指针，即一个链表，存储所有映射到这一项的符号。增加符号时，先查找是否存在同层作用域的同名符号，或不同层的同名的结构体定义，如果有，则添加失败；否则添加成功。查找符号时，有两个函数结构，分别是全局查找和同作用域查找。删除符号主要是从语句块返回时，将当前作用域的符号删除。

- 类型的实现及其结构等价判断

  定义了`struct Type_`结构体，用来描述符号的类型。其中的`kind`成员指明是哪一种类型，`u`成员具体描述该类型的具体信息（如函数的参数，结构体的成员等）。我们加入了函数这一类型，并加入了`STRUCTDEF`类型，用来表示结构体的定义，与结构体的实例区别开来。所有的类型和与其对应的存储方式如下表。

  |    类型     | kind成员  |                    u成员                    |
  | :---------: | :-------: | :-----------------------------------------: |
  | Int / float |   BASIC   |                   u.basic                   |
  |    array    |   ARRAY   |                   u.array                   |
  | Struct实例  | STRUCTURE | u.structure（只存结构体名称，不存具体信息） |
  | 匿名struct  | STRUCTURE |     u.structure（存储结构体的具体信息）     |
  | struct定义  | STRUCTDEF |     u.structure（存储结构体的具体信息）     |
  |  function   | FUNCTION  |                 u.function                  |

  定义了`typeEqual(Type type1, Type type2)`函数，用于判断两个类型是否结构等价。我们先对`type1`和`type2`中有`NULL`的情况进行讨论（若某个`Exp`发生错误，它返回的类型会是`NULL`），接着比较他们的`kind`成员，针对他们的每个域进行逐一比较。值得注意的是，结构体的部分，匿名结构体需要特殊处理之后，才能进行比较。

- 嵌套作用域的实现

  我们定义了一个全局变量`depth`，用来记录当前嵌套的层数，每次进入语句块的时候（包括函数的形参加入符号表时），将`depth`加一，退出时减一并清空这一层加入符号表的所有变量。

  为了实现这样的效果，我们定义了一个数组`stack`，`stack[i]`将所有嵌套第i层的符号“串起来”，便于进行统一的管理。

  其中值得注意的是，无论嵌套了多少层，其中结构体的定义应当加入全局符号表，而不是这一层的。

- 函数声明的实现

  实现函数声明，需要先添加产生式，这很简单，加入`ExtDef→Specifier FunDec SEMI`即可。

  还需要在`struct Type_`结构体中函数部分添加一个`int`变量`hasdef`，来记录函数有没有被定义。我们规定如果有了定义，`hasdef=0`，否则`hasdef`的值记录为当前声明的行号。这样做是为了在遍历完语法树后检查符号表，若遇到未定义的函数，报错时可以打印出声明所在的行号。

- 语义检查的流程

  进行语义检查时，我们遍历语法树。为了防止不同的节点被处理很多次，我们只有遇到`ExtDef`节点时，才调用`ExtDefProcess`函数进行处理，然后在在这个函数中，再调用其他函数，对子节点进行处理。每当遇到语法单元`ExtDef`或者`Def`，就说明该结点的子结点们包含了变量或者函数的定义信息，这时候应当将这些信息通过对子结点们的遍历提炼出来并插入到符号表里。每当遇到语法单元`Exp`，说明该结点及其子结点们会对变量或者函数进行使用，这个时候应当查符号表以确认这些变量或者函数是否存在以及它们的类型是什么。


## 中间代码生成与优化
在对c--语言的语义分析的基础上，输出编译后的中间代码，并对中间代码进行优化。
- 依照语法树翻译为中间代码，将变量重新编号

- 实现了结构体和数组变量，进行内存申请

- 实现了数组和结构体的递归按域展开赋值

- 优化中间代码
    - 局部常量传播
    ```cpp
    t1 := #1
    ```
    将`t1`全部替换为`1`直到它的值被改变
    - 复制传播
    ```cpp
    t1 := v1
    ```
    将`t1`全部替换为`v1`直到它的值被改变
    - 消除死代码
    
    - 代数恒等式优化求值
    
    - 窥孔优化
    
      |                        原代码                         |                            优化后                            |
      | :---------------------------------------------------: | :----------------------------------------------------------: |
      |                t1 := CALL  f  v1 := t1                |                        v1 := CALL  f                         |
      |                   READ t1  v1 := t1                   |                           READ v1                            |
      |              LABEL label1  LABEL  label2              |          LABEL  label1  并将所有label2替换为label1           |
      |               GOTO label1  非LABEL语句                |                         GOTO  label1                         |
      |              GOTO  label1  LABEL  label1              |                        LABEL  label1                         |
      | IF t1 op  t2 GOTO label1  GOTO  label2  LABEL  label1 | IF t1 nop  t2 GOTO label2  GOTO  label1  LABEL  label1  （nop是op的相反操作符） |
      |             t1 := t2 +  #1  t3 := t1 + #2             |                t3:= t2 +  #3  （或者+换成*）                 |
      |            t1 := t2 +  v1  t3 := t1  - v1             |                  t3 := t2  （或者先减后加）                  |

- 可使用提供的Qt中间代码模拟器`irsim.pyc`进行正确性验证

## 生成MIPS汇编代码

将中间代码逐条或多对一翻译成MIPS汇编代码。

- 设计了`Register`结构体和`Varible`结构体，分别保存32个寄存器和程序中出现的变量，并在其中添加了寄存器描述符和变量描述符，表示某个寄存器存储哪个变量，以及某个变量存储在哪个寄存器。
- 能够自由使用的寄存器共有19个，分别是`$t0 ~ $t9，$s0 ~ $s7，$v1`。`$v0`专门用作函数返回值，`$a0 ~ $a3`专门用作函数参数，`$s8`用作栈指针`$fp`，用来标志变量地址的基址。

- 具体设计时，分为`ensureReg()`和`allocateReg()`两个函数。

- 如果申请寄存器变量为函数参数，直接返回参数寄存器`$ai`，i = 0,1,2,3；如果它已经在某个寄存器中，直接返回；否则需要分配寄存器。若有空闲的，直接分配；如果没有空闲的，随机选择一个寄存器将存储的变量溢出，分配给它。

- 函数调用的活动记录设计如下：

  | `  $a0 ~ $a3`中被调用者用作参数的 |
  | :-------------------------------: |
  |              `$fp `               |
  |             `  $ra  `             |
  |         `  argument 5  `          |
  |          ` argument 6  `          |
  |                ……                 |
  |          ` argument   `           |
  |        `  active reg 1  `         |
  |        `  active reg 2  `         |
  |                ……                 |
  |        `  active reg n  `         |

  

- 一开始生成的代码数量过多，命令行的spim最多只能支持一万多条指令（Qtspim可以支持），所以我们划分了基本块，构建了流图，在流图中到达不了的基本块都是死代码，直接删除即可。

- Label指令之后寄存器的使用情况有可能发生变化，所以在跳转语句和LABEL语句之前都将所有变量溢出。

- 使用mips32模拟器spim测试代码正确性：[spim](https://spimsimulator.sourceforge.net/)

